1. string, number, boolean

2. string[], number[], any[]


3. any
특정한 값에 타입에러를 야기시키기를 원하지 않을 떄 사용하는 타입이다.
any는 유형검사를 하지 않는다. => tsconfig, noImplicitAny의 true는 any 사용시 error로 표현한다.


4. 타입을 추론하는 기능 덕분에 let, const의 변수 선언/할당 마다 타입 선언을 할 필요가 없다.


5. function
5-1. 함수의 매개변수 모두 타입을 지정해야 한다. (추론적으로 타입을 알 수 없다.)
5-2. 반환 타입을 지정할 수 있다. (추론적으로 알 수 있지만 강력한 타입지정을 위해 설정할 수 도 있다.)
5-3. promise 타입이 존재한다.
=> async function lll() : promise{...};

5-4. 익명 함수
=> JS func, 브라우저 함수의 경우 매개변수가 정해져있기 떄문에 타입지정할 필요없다.
=> 컨텍스트 타이핑이라고 한다.


6. Object-Types
6-1. {키 : types}를 통해 나열하면 된다.
ex) let obj = {name : string, age : number}

6-2. optional Properties => ?
=> 객체 타입을 지정할 떄 해당 프로퍼티가 없을 수 도 있다고 설명하는 ?
=> 키? : type 순서이다.


7. Union-Types
7-1. 둘 이상의 다른 유형으로 구성된 유형을 유니언 타입이라고 한다.

7-2. 유니언 타입으로 지정했을 떄 두 타입이 모두 갖고 있는 프로퍼티만 사용가능하다.
=> 타입을 사용하는 곳에서 타입을 narrow해야 한다. 
=> typeof, instanceof, Array.isArray...


8. Type-Alias
8-1. Type typeName = string | number
8-2. Type objType1 = {name : string, age : number};


9. Type-Assertions(형 변환)
as, <>를 이용해서 어떤 타입인지 TS에게 알려준다.
=> 타입 지정으로는 식별이 불가능할 떄
=> TS는 HTML을 읽지 않기떄문에 HTML ELEMENT에 접근할 떄/ DOM과 소통할 떄 


10. Literal Types
string => 'as-text';
number => 209;

type = 'as-text' | 'as-number' | 209; => 더욱 구체적으로 지정할 수 있다.


11. null, undefined

11.1 ! => 변수뒤에 !가 붙으면 해당 변수는 null, undefined가 아니라고 TS가 이해한다.


12. type Assertion
=> 형 변환이라고 부른다.









