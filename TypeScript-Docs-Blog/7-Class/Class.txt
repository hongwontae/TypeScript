1. 클래스의 본문에 인스턴스 변수(생성자 함수를 호출할 떄 전달할 변수)을 먼저 정의해줘야 한다.
1-1. constructor 매개변수에 public or readonly + 변수 + 타입을 같이 사용하면 클래스 본문에서 초기화 필요없다.


2. Class extends
2-1. 상속받을 수 있는 클래스는 무조건 1개이다.
2-2. extends를 사용하여 자식-부모 관계를 맺을 수 있다.
2-3. 자식 클래스에서 override 가능하다.
2-4. 자식 클래스에서는 부모 클래스의 constructor을 가져오기 위해 super()를 사용해야 한다.


3. 클래스 접근 제어자
3-1. 속성과 메서드에서 사용이 가능하다.

3-1. public
=> 이 키워드가 붙은 속성과 메서드를 어디에서나 접근이 가능하다.

3-2. protected
=> 해당 키워드가 붙은 속성, 메서드는 외부에서 접근이 불가능하고 자신의 클래스 내부, 상속한 자식 클래스 내부에서만 접근이 가능하다.

3-3. private
=> 클래스 내부에서만 접근이 가능하다.
=> JS에서도 #를 사용하면 변수를 private으로 사용이 가능하다.


4. static
4-1. 인스턴스의 변수, 메서드를 정의하는 것이 아닌 클래스 자체의 속성과 메서드를 정의하는 것이다.
4-2. static 키워드를 사용해서 정의하면 된다.


5. readonly
5-1. 읽기 전용이 된다.
5-2. 인스턴스화 될 떄의 초기화의 값은 받아들인다. => 초기화 이후 할당 불가능


6. getter/setter
6-1. 클래스 내부에서 get/set 키워드를 사용해서 속성의 접근과 할당을 해주는 메서드를 의미한다.
6-2. 둘 다 접근으로 값을 가져오고 값을 할당한다.
=> console.log(instance.getName)/ instance.setName = 'HWHWT';

7. 구성 시그니쳐
7-1. 함수 매개변수에 클래스를 전달해서, 함수를 호출하면 클래스가 초기화되는 로직 => 인터페이스 구성 시그니처
7-2. new 키워드 사용하는 호출 시그니처와 비슷하다.


8. 추상 클래스
8-1. abstract 키워드를 붙여서 사용하면 추상 속성, 추상 메서드 => 오버라이딩해야 한다.
8-2. abstract이란 키워드가 하나라도 존재하면 해당 클래스에 abstract 키워드가 붙어야 하고 해당 클래스는 인스턴스화 불가
8-3. abstract 클래스에서 constructor, 일반 속성, 메서드 구현 가능 => 자식이 가질 수 있다.


9. 오버라이딩의 조건
9-1. 매개변수 숫자가 같아야 한다. 단, 매개변수명은 달라도 된다.
9-2. 매개변수 타입이 같거나, 하위 타입이여야 한다.
9-3. 리턴 타입이 같아야 한다.




